import { EMPTY } from './magic';
var put = function (node, str, value, edgeNodes, values, edgeDelimiter) {
    var nextNode;
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var c = str_1[_i];
        nextNode = node[c];
        if (!nextNode) {
            nextNode = node[c] = Object.create(EMPTY);
            if (c === edgeDelimiter) {
                edgeNodes.delete(node);
            }
        }
        node = nextNode;
    }
    edgeNodes.set(node, str);
    values.set(node, value);
    return nextNode;
};
var get = function (node, str) {
    var nextNode;
    for (var _i = 0, str_2 = str; _i < str_2.length; _i++) {
        var c = str_2[_i];
        nextNode = node[c];
        if (!nextNode) {
            return false;
        }
        node = nextNode;
    }
    return nextNode;
};
var getNearest = function (node, str) {
    var nextNode;
    var found = '';
    for (var _i = 0, str_3 = str; _i < str_3.length; _i++) {
        var c = str_3[_i];
        nextNode = node[c];
        if (!nextNode) {
            return { node: node, path: found, isComplete: false };
        }
        found += c;
        node = nextNode;
    }
    return {
        node: node,
        path: str,
        isComplete: true
    };
};
/**
 * builds a "char" based search trie.
 * Optimized for random inputs with unpredictable variation
 *
 * pros:
 * - more stable speed at large sets
 * - every character matters, you can get the longest prefix available even without value
 *
 * cons:
 * - more operations are required to perform a single search
 *
 * - input: array of {key:string, value}
 */
export var buildCharacterTrie = function (words, edgeDelimiter) {
    if (edgeDelimiter === void 0) { edgeDelimiter = '.'; }
    var root = Object.create(EMPTY);
    var edgeNodes = new Map();
    var values = new WeakMap();
    for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
        var _a = words_1[_i], key = _a.key, value = _a.value;
        put(root, key, value, edgeNodes, values, edgeDelimiter);
    }
    return {
        has: function (word) {
            return Boolean(get(root, word));
        },
        findNearest: function (word) {
            var _a = getNearest(root, word), node = _a.node, path = _a.path, isComplete = _a.isComplete;
            return {
                value: values.get(node),
                path: path,
                isComplete: isComplete
            };
        },
        get: function (word) {
            var node = get(root, word);
            return node ? values.get(node) : undefined;
        },
        put: function (word, value) {
            put(root, word, value, edgeNodes, values, edgeDelimiter);
        },
    };
};
