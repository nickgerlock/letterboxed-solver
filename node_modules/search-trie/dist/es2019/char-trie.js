import { EMPTY } from './magic';
const put = (node, str, value, edgeNodes, values, edgeDelimiter) => {
    let nextNode;
    for (const c of str) {
        nextNode = node[c];
        if (!nextNode) {
            nextNode = node[c] = Object.create(EMPTY);
            if (c === edgeDelimiter) {
                edgeNodes.delete(node);
            }
        }
        node = nextNode;
    }
    edgeNodes.set(node, str);
    values.set(node, value);
    return nextNode;
};
const get = (node, str) => {
    let nextNode;
    for (const c of str) {
        nextNode = node[c];
        if (!nextNode) {
            return false;
        }
        node = nextNode;
    }
    return nextNode;
};
const getNearest = (node, str) => {
    let nextNode;
    let found = '';
    for (const c of str) {
        nextNode = node[c];
        if (!nextNode) {
            return { node, path: found, isComplete: false };
        }
        found += c;
        node = nextNode;
    }
    return {
        node,
        path: str,
        isComplete: true
    };
};
/**
 * builds a "char" based search trie.
 * Optimized for random inputs with unpredictable variation
 *
 * pros:
 * - more stable speed at large sets
 * - every character matters, you can get the longest prefix available even without value
 *
 * cons:
 * - more operations are required to perform a single search
 *
 * - input: array of {key:string, value}
 */
export const buildCharacterTrie = (words, edgeDelimiter = '.') => {
    const root = Object.create(EMPTY);
    const edgeNodes = new Map();
    const values = new WeakMap();
    for (const { key, value } of words) {
        put(root, key, value, edgeNodes, values, edgeDelimiter);
    }
    return {
        has(word) {
            return Boolean(get(root, word));
        },
        findNearest(word) {
            const { node, path, isComplete } = getNearest(root, word);
            return {
                value: values.get(node),
                path,
                isComplete
            };
        },
        get(word) {
            const node = get(root, word);
            return node ? values.get(node) : undefined;
        },
        put(word, value) {
            put(root, word, value, edgeNodes, values, edgeDelimiter);
        },
    };
};
